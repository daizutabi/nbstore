{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nbstore","text":"<p>nbstore is a library for creating, manipulating, and integrating Jupyter notebooks with Markdown documentation. It serves as the foundation for the MkDocs plugin nbsync.</p>"},{"location":"#what-is-nbstore","title":"What is nbstore?","text":"<p>nbstore bridges the gap between Jupyter notebooks, Python scripts, and Markdown documentation. It solves common challenges that data scientists, researchers, and technical writers face when working with notebooks:</p> <ul> <li>Development happens in notebooks - ideal for experimentation and visualization</li> <li>Documentation lives in markdown - perfect for narrative and explanation</li> <li>Traditional integration is challenging - screenshots break, exports get outdated</li> </ul> <p>With nbstore, you can:</p> <ul> <li>Generate notebooks from Python scripts and Markdown files</li> <li>Extract and manipulate content from notebook cells</li> <li>Execute code embedded in image notations</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#notebooks-from-python-and-markdown","title":"Notebooks from Python and Markdown","text":"<p>Create Jupyter notebooks directly from Python scripts and Markdown files with special syntax for code blocks and cell identification.</p>"},{"location":"#cell-identification","title":"Cell Identification","text":"<p>Access notebook cells using <code>#id</code> comments, allowing you to get source code or output results from specific cells.</p>"},{"location":"#inline-code-in-images","title":"Inline Code in Images","text":"<p>Write executable code within image notation, enabling dynamic visualization placement.</p>"},{"location":"#notebook-cell-addition","title":"Notebook Cell Addition","text":"<p>Add new cells to notebooks programmatically.</p>"},{"location":"#notebook-execution","title":"Notebook Execution","text":"<p>Execute notebooks and capture their outputs.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install nbstore\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>nbstore provides a powerful set of features for working with Jupyter notebooks, Python scripts, and Markdown files.</p>"},{"location":"features/#markdown-to-notebook-conversion","title":"Markdown to Notebook Conversion","text":"<p>Convert Markdown files to Jupyter notebooks with support for custom syntax and attributes. Use code blocks with language specification and identifiers to create notebook cells.</p> <pre><code># Example: Converting Markdown to a notebook\nfrom pathlib import Path\nfrom nbstore.markdown import new_notebook\n\n# Read the Markdown file\ntext = Path(\"document.md\").read_text()\n\nnotebook = new_notebook(text)\n</code></pre>"},{"location":"features/#cell-identification-and-access","title":"Cell Identification and Access","text":"<p>Access specific cells in notebooks using unique identifiers, supporting both source code extraction and output retrieval.</p> <pre><code># Example: Accessing a cell by ID\nfrom nbstore.notebook import get_source, get_data\n\n# Get source code from cell with ID \"plot\"\nsource = get_source(notebook, \"plot\")\n\n# Get output data from the same cell\ndata = get_data(notebook, \"plot\")\n</code></pre>"},{"location":"features/#inline-code-execution","title":"Inline Code Execution","text":"<p>Execute Python code within image notation, making it easy to generate and include dynamic visualizations.</p>"},{"location":"features/markdown/","title":"Markdown Processing","text":"<p>nbstore includes a robust Markdown parser with support for code blocks, images, and custom attributes for identifying and styling elements.</p>"},{"location":"features/markdown/#code-blocks","title":"Code Blocks","text":"<p>Code blocks in Markdown can be converted to notebook cells by adding an identifier and language specification.</p> <pre><code>```python .md#plot\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\nplt.plot(x, np.sin(x))\nplt.title(\"Sine Function\")\n```\n</code></pre> <p>The <code>.md#plot</code> identifier can later be used to access this particular cell or its outputs.</p>"},{"location":"features/markdown/#images-with-source","title":"Images with Source","text":"<p>nbstore extends the standard Markdown image syntax to support inline code and attributes:</p> <pre><code>![Plot result](.md){#plot source=\"on\"}\n</code></pre> <p>Or with inline code:</p> <pre><code>![Plot result](){`plt.plot(x, np.sin(x))`}\n</code></pre>"},{"location":"features/markdown/#parsing-example","title":"Parsing Example","text":"<pre><code>from pathlib import Path\nfrom nbstore.markdown import parse, CodeBlock\n\n# Parse a Markdown file\ntext = Path(\"document.md\").read_text()\n\n# Iterate through parsed elements\nfor element in parse(text):\n    if isinstance(element, CodeBlock) and element.identifier:\n        print(f\"Found code block with ID: {element.identifier}\")\n        print(f\"Language: {element.classes[0] if element.classes else 'none'}\")\n        print(f\"Source: {element.source}\")\n</code></pre>"},{"location":"features/notebook/","title":"Notebook Operations","text":"<p>nbstore provides comprehensive functions for working with Jupyter notebooks, including cell access, output extraction, and notebook execution.</p>"},{"location":"features/notebook/#cell-access","title":"Cell Access","text":"<p>Access specific cells in notebooks using unique identifiers:</p> <pre><code>from nbstore.notebook import get_cell, get_source\n\n# Get the entire cell\ncell = get_cell(notebook, \"plot\")\n\n# Get just the source code, optionally excluding the identifier line\nsource = get_source(notebook, \"plot\", include_identifier=False)\n</code></pre>"},{"location":"features/notebook/#output-extraction","title":"Output Extraction","text":"<p>Extract and work with cell outputs in various formats:</p> <pre><code>from nbstore.notebook import get_outputs, get_data, get_mime_content, get_stream\n\n# Get all outputs from a cell\noutputs = get_outputs(notebook, \"plot\")\n\n# Get data outputs as a dictionary\ndata = get_data(notebook, \"plot\")\n\n# Get content with MIME type information\nmime_content = get_mime_content(notebook, \"plot\")\n\n# Get stream output (stdout/stderr)\nstream = get_stream(notebook, \"plot\")\n</code></pre>"},{"location":"features/notebook/#notebook-creation","title":"Notebook Creation","text":"<p>Create new notebooks and add cells:</p> <pre><code>import nbformat\nfrom nbstore.notebook import new_code_cell\n\n# Create a new notebook\nnotebook = nbformat.v4.new_notebook()\n\n# Add a cell with an identifier\ncell = new_code_cell(\"plot\", \"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\nplt.plot(x, np.sin(x))\n\"\"\")\n\nnotebook[\"cells\"].append(cell)\n</code></pre>"},{"location":"features/notebook/#notebook-execution","title":"Notebook Execution","text":"<p>Execute notebooks and capture outputs:</p> <pre><code>from nbstore.notebook import execute\n\n# Execute the notebook\nexecuted_notebook, execution_info = execute(notebook)\n\n# Now outputs are available\ndata = get_data(executed_notebook, \"plot\")\n</code></pre>"},{"location":"features/notebook/#special-output-handling","title":"Special Output Handling","text":"<p>nbstore has special handling for various output formats:</p> <pre><code># For Matplotlib PGF backend\n# Base64-encoded images in outputs are automatically handled\nmime_type, content = get_mime_content(notebook, \"image_cell\")\n</code></pre>"},{"location":"features/notebook/#notebook-comparison","title":"Notebook Comparison","text":"<p>Compare notebooks to check for equality:</p> <pre><code>from nbstore.notebook import equals\n\n# Check if two notebooks have the same cells\nif equals(notebook1, notebook2):\n    print(\"Notebooks are identical\")\n</code></pre>"},{"location":"api/nbstore/","title":"nbstore","text":"nbstore<p> source package nbstore </p> <p>Extract and manipulate content from Jupyter notebooks.</p> <p>nbstore provides tools for reading, processing, and storing notebook content, with support for multiple formats including .ipynb, .py, and .md files. It facilitates extraction of specific cells, data conversion, and formatting of visualization outputs.</p> <p> Main components </p> <ul> <li>Store: Main interface for reading and managing notebook files</li> <li>Formatter: Controls output format for visualization libraries</li> <li>Content parsing for Python and Markdown files</li> </ul> <p> Classes </p> <ul> <li> <p>Store \u2014 Manage notebook files from one or more source directories.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>read \u2014 Read a notebook file and return its content.</p> </li> <li> <p>set_formatter \u2014 Set a formatter for visualization outputs.</p> </li> </ul> <p> source class Store(src_dirs: str | Path | Iterable[str | Path]) </p> <p>Manage notebook files from one or more source directories.</p> <p>Provides a centralized interface for reading notebook files and caching their content for efficient access. Automatically reloads files when they have been modified on disk.</p> <p>Initialize a new Store instance.</p> <p> Attributes </p> <ul> <li> <p>src_dirs :  list[Path] \u2014 List of source directories to search for notebook files.</p> </li> <li> <p>nodes :  dict[Path, NotebookNode] \u2014 Dictionary mapping file paths to their notebook nodes.</p> </li> <li> <p>st_mtime :  dict[Path, float] \u2014 Dictionary mapping file paths to their last modification times.</p> </li> <li> <p>url :  str \u2014 String representing the last accessed URL.</p> </li> </ul> <p> Parameters </p> <ul> <li> <p>src_dirs :  str | Path | Iterable[str | Path] \u2014 One or more directories to search for notebook files. Can be a single path or a collection of paths.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>find_path \u2014 Find the absolute path of a notebook file.</p> </li> <li> <p>read \u2014 Read a notebook file and return its content.</p> </li> <li> <p>write \u2014 Write a notebook node to a file.</p> </li> </ul> <p> source method Store.find_path(url: str) \u2192 Path </p> <p>Find the absolute path of a notebook file.</p> <p>Searches for the notebook file in the source directories. If the URL is an absolute path, it is returned directly.</p> <p> Parameters </p> <ul> <li> <p>url :  str \u2014 The URL or relative path of the notebook file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Path \u2014 The absolute path to the notebook file.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If the file cannot be found in any source directory.</p> </li> </ul> <p> source method Store.read(url: str) \u2192 NotebookNode </p> <p>Read a notebook file and return its content.</p> <p>If the file has been modified since it was last read, it is reloaded. If no URL is provided, the last URL is used.</p> <p> Parameters </p> <ul> <li> <p>url :  str \u2014 The URL or relative path of the notebook file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>NotebookNode \u2014 The notebook content.</p> </li> </ul> <p> source method Store.write(url: str, notebook_node: NotebookNode) \u2192 None </p> <p>Write a notebook node to a file.</p> <p>Currently only supports writing to .ipynb files.</p> <p> Parameters </p> <ul> <li> <p>url :  str \u2014 The URL or relative path of the notebook file.</p> </li> <li> <p>notebook_node :  NotebookNode \u2014 The notebook content to write.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>NotImplementedError \u2014 If the file format is not supported for writing.</p> </li> </ul> <p> source read(path: str | Path) \u2192 NotebookNode </p> <p>Read a notebook file and return its content.</p> <p>Supports .ipynb, .py, and .md file formats.</p> <p> Parameters </p> <ul> <li> <p>path :  str | Path \u2014 The path to the notebook file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>NotebookNode \u2014 The notebook content.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>NotImplementedError \u2014 If the file format is not supported.</p> </li> </ul> <p> source set_formatter(module: str, fmt: str, ip: InteractiveShell | None = None) \u2192 None </p> <p>Set a formatter for visualization outputs.</p> <p>Registers a formatter for the specified module and format with IPython.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The module to set the formatter for ('matplotlib', 'seaborn', 'holoviews').</p> </li> <li> <p>fmt :  str \u2014 The format to use ('pgf', 'pdf', 'svg').</p> </li> <li> <p>ip :  InteractiveShell | None \u2014 Optional IPython instance. If None, get_ipython() is used.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>NotImplementedError \u2014 If the format is not supported.</p> </li> <li> <p>ModuleNotFoundError \u2014 If IPython is not installed.</p> </li> </ul>"},{"location":"api/nbstore/formatter/","title":"nbstore.formatter","text":"nbstore.formatter<p> source module nbstore.formatter </p> <p>Formatters for visualization outputs in notebooks.</p> <p>This module provides functions for converting visualization outputs from various libraries (matplotlib, seaborn, holoviews) to different formats (PGF, PDF, SVG), and utilities for registering these formatters with IPython.</p> <p> Functions </p> <ul> <li> <p>matplotlib_figure_to_pgf \u2014 Convert a matplotlib figure to PGF format.</p> </li> <li> <p>matplotlib_figure_to_pdf \u2014 Convert a matplotlib figure to PDF format.</p> </li> <li> <p>matplotlib_figure_to_svg \u2014 Convert a matplotlib figure to SVG format.</p> </li> <li> <p>seaborn_plot_to_pgf \u2014 Convert a seaborn plot to PGF format.</p> </li> <li> <p>seaborn_plot_to_pdf \u2014 Convert a seaborn plot to PDF format.</p> </li> <li> <p>seaborn_plot_to_svg \u2014 Convert a seaborn plot to SVG format.</p> </li> <li> <p>set_formatter_holoviews \u2014 Set a formatter for holoviews.</p> </li> <li> <p>set_formatter \u2014 Set a formatter for visualization outputs.</p> </li> </ul> <p> source matplotlib_figure_to_pgf(fig: Figure, rp: RepresentationPrinter, cycle) \u2192 None </p> <p>Convert a matplotlib figure to PGF format.</p> <p>Creates a temporary PGF file, reads its content, encodes embedded images as base64, and outputs the result using the representation printer.</p> <p> Parameters </p> <ul> <li> <p>fig :  Figure \u2014 The matplotlib figure to convert.</p> </li> <li> <p>rp :  RepresentationPrinter \u2014 The printer to output the result.</p> </li> <li> <p>cycle \u2014 Object passed by IPython for object representation.</p> </li> </ul> <p> source matplotlib_figure_to_pdf(fig: Figure) \u2192 bytes </p> <p>Convert a matplotlib figure to PDF format.</p> <p> Parameters </p> <ul> <li> <p>fig :  Figure \u2014 The matplotlib figure to convert.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bytes \u2014 The PDF content as bytes.</p> </li> </ul> <p> source matplotlib_figure_to_svg(fig: Figure) \u2192 str </p> <p>Convert a matplotlib figure to SVG format.</p> <p> Parameters </p> <ul> <li> <p>fig :  Figure \u2014 The matplotlib figure to convert.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The SVG content as a string.</p> </li> </ul> <p> source seaborn_plot_to_pgf(plot: Plot, rp: RepresentationPrinter, cycle) \u2192 None </p> <p>Convert a seaborn plot to PGF format.</p> <p> Parameters </p> <ul> <li> <p>plot :  Plot \u2014 The seaborn plot to convert.</p> </li> <li> <p>rp :  RepresentationPrinter \u2014 The printer to output the result.</p> </li> <li> <p>cycle \u2014 Object passed by IPython for object representation.</p> </li> </ul> <p> source seaborn_plot_to_pdf(plot: Plot) \u2192 bytes </p> <p>Convert a seaborn plot to PDF format.</p> <p> Parameters </p> <ul> <li> <p>plot :  Plot \u2014 The seaborn plot to convert.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bytes \u2014 The PDF content as bytes.</p> </li> </ul> <p> source seaborn_plot_to_svg(plot: Plot) \u2192 str </p> <p>Convert a seaborn plot to SVG format.</p> <p> Parameters </p> <ul> <li> <p>plot :  Plot \u2014 The seaborn plot to convert.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The SVG content as a string.</p> </li> </ul> <p> source set_formatter_holoviews(fmt: str) \u2192 None </p> <p>Set a formatter for holoviews.</p> <p>Registers a formatter for holoviews elements in the specified format.</p> <p> Parameters </p> <ul> <li> <p>fmt :  str \u2014 The format to use ('pgf', 'pdf', 'svg').</p> </li> </ul> <p> source set_formatter(module: str, fmt: str, ip: InteractiveShell | None = None) \u2192 None </p> <p>Set a formatter for visualization outputs.</p> <p>Registers a formatter for the specified module and format with IPython.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The module to set the formatter for ('matplotlib', 'seaborn', 'holoviews').</p> </li> <li> <p>fmt :  str \u2014 The format to use ('pgf', 'pdf', 'svg').</p> </li> <li> <p>ip :  InteractiveShell | None \u2014 Optional IPython instance. If None, get_ipython() is used.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>NotImplementedError \u2014 If the format is not supported.</p> </li> <li> <p>ModuleNotFoundError \u2014 If IPython is not installed.</p> </li> </ul>"},{"location":"api/nbstore/markdown/","title":"nbstore.markdown","text":"nbstore.markdown<p> source module nbstore.markdown </p> <p>Convert Markdown files to Jupyter notebooks.</p> <p>This module provides utilities for parsing Markdown files and converting them to notebook format, with support for code blocks, images, and custom attributes. It implements a robust parser for Markdown syntax including code blocks with language specification and attributes.</p> <p> Classes </p> <ul> <li> <p>Matcher</p> </li> <li> <p>Comment \u2014 A comment in Markdown.</p> </li> <li> <p>Element \u2014 Base class for Markdown elements with attributes.</p> </li> <li> <p>CodeBlock \u2014 A code block in Markdown.</p> </li> <li> <p>Image \u2014 An image in Markdown.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>split \u2014 Split text into parts, handling key=value pairs.</p> </li> <li> <p>parse \u2014 Parse the text and yield elements.</p> </li> <li> <p>get_language \u2014 Get the language of a Markdown document.</p> </li> <li> <p>is_target_code_block \u2014 Check if an element is a code block with the target language.</p> </li> <li> <p>new_notebook \u2014 Create a new notebook from Markdown text.</p> </li> </ul> <p> source split(text: str) \u2192 Iterator[str] </p> <p>Split text into parts, handling key=value pairs.</p> <p>Builds on _split by additionally recognizing and combining key=value pairs into single parts.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The text to split.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 The split parts.</p> </li> </ul> <p> source dataclass Matcher() </p> <p> Methods </p> <ul> <li> <p>from_match \u2014 Create an element from a regex match.</p> </li> <li> <p>iter_elements \u2014 Iterate through elements in the text.</p> </li> </ul> <p> source classmethod Matcher.from_match(match: re.Match[str]) \u2192 Self | str </p> <p>Create an element from a regex match.</p> <p> Parameters </p> <ul> <li> <p>match :  re.Match[str] \u2014 The regex match object.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Self \u2014 The created element.</p> </li> </ul> <p> source classmethod Matcher.iter_elements(text: str, pos: int = 0, endpos: int | None = None) \u2192 Iterator[Self | str | tuple[int, int]] </p> <p>Iterate through elements in the text.</p> <p>Finds all occurrences of the element pattern in the text and yields either element instances or text spans.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The text to search.</p> </li> <li> <p>pos :  int \u2014 The starting position.</p> </li> <li> <p>endpos :  int | None \u2014 The ending position.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Self | tuple[int, int] \u2014 Element instances or text spans.</p> </li> </ul> <p> source dataclass Comment() </p> <p>Bases : Matcher</p> <p>A comment in Markdown.</p> <p> source dataclass Element(text: str, identifier: str, classes: list[str], attributes: dict[str, str], source: str = '', url: str = '', indent: str = '') </p> <p>Bases : Matcher</p> <p>Base class for Markdown elements with attributes.</p> <p>Represents a structured element in a Markdown document, with support for identifiers, classes, attributes, and other properties.</p> <p> Attributes </p> <ul> <li> <p>pattern :  ClassVar[re.Pattern[str]] \u2014 Regular expression pattern to match the element in text.</p> </li> <li> <p>text :  str \u2014 The original text of the element.</p> </li> <li> <p>identifier :  str \u2014 The ID of the element.</p> </li> <li> <p>classes :  list[str] \u2014 List of class names for the element.</p> </li> <li> <p>attributes :  dict[str, str] \u2014 Dictionary of attribute key-value pairs.</p> </li> <li> <p>code \u2014 The code content of the element (for code blocks).</p> </li> <li> <p>url :  str \u2014 The URL of the element (for links and images).</p> </li> </ul> <p> Methods </p> <ul> <li> <p>iter_parts \u2014 Iterate through the parts of the element's attributes.</p> </li> </ul> <p> source method Element.iter_parts(*, include_identifier: bool = False, include_classes: bool = True, include_attributes: bool = True, exclude_attributes: Iterable[str] = ()) \u2192 Iterator[str] </p> <p>Iterate through the parts of the element's attributes.</p> <p> Parameters </p> <ul> <li> <p>include_identifier :  bool \u2014 Whether to include the identifier.</p> </li> <li> <p>include_classes :  bool \u2014 Whether to include the classes.</p> </li> <li> <p>include_attributes :  bool \u2014 Whether to include the attributes.</p> </li> <li> <p>exclude_attributes :  Iterable[str] \u2014 Attributes to exclude.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 The parts of the element's attributes.</p> </li> </ul> <p> source dataclass CodeBlock(text: str, identifier: str, classes: list[str], attributes: dict[str, str], source: str = '', url: str = '', indent: str = '') </p> <p>Bases : Element</p> <p>A code block in Markdown.</p> <p>Represents a fenced code block, with support for language specification and attributes.</p> <p> Example </p> <p><code>python #id print(\"Hello, world!\")</code></p> <p> Methods </p> <ul> <li> <p>from_match</p> </li> </ul> <p> source classmethod CodeBlock.from_match(match: re.Match[str]) \u2192 Self </p> <p> source dataclass Image(text: str, identifier: str, classes: list[str], attributes: dict[str, str], source: str = '', url: str = '', indent: str = '', alt: str = '') </p> <p>Bases : Element</p> <p>An image in Markdown.</p> <p>Represents an image with alt text, URL, and attributes.</p> <p> Example </p> <p><code>![Alt text](image.png){#id .class width=100}</code></p> <p> Methods </p> <ul> <li> <p>from_match</p> </li> </ul> <p> source classmethod Image.from_match(match: re.Match[str]) \u2192 Self </p> <p> source parse(text: str, pos: int = 0, endpos: int | None = None, classes: tuple[type[Matcher], ...] = (Comment, CodeBlock, Image)) \u2192 Iterator[CodeBlock | Image | str] </p> <p>Parse the text and yield elements.</p> <p>Finds all occurrences of the specified element types in the text and yields either element instances or text segments between elements.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The text to search.</p> </li> <li> <p>pos :  int \u2014 The starting position.</p> </li> <li> <p>endpos :  int | None \u2014 The ending position.</p> </li> <li> <p>classes :  tuple[type[Element], ...] \u2014 The element types to find.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>Element | str \u2014 Element instances or text segments.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source get_language(text: str) \u2192 str </p> <p>Get the language of a Markdown document.</p> <p>Determines the primary programming language used in the document's code blocks.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The Markdown text.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The detected language, or \"python\" if not detected.</p> </li> </ul> <p> source is_target_code_block(elem: Element | str, language: str) \u2192 TypeGuard[CodeBlock] </p> <p>Check if an element is a code block with the target language.</p> <p> Parameters </p> <ul> <li> <p>elem :  Element | str \u2014 The element to check.</p> </li> <li> <p>language :  str \u2014 The target language.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>TypeGuard[CodeBlock] \u2014 True if the element is a code block with the     target language, False otherwise.</p> </li> </ul> <p> source new_notebook(text: str) \u2192 NotebookNode </p> <p>Create a new notebook from Markdown text.</p> <p>Parses the Markdown text, extracts code blocks, and creates a notebook with a code cell for each code block.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The Markdown text.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>NotebookNode \u2014 The created notebook.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/nbstore/notebook/","title":"nbstore.notebook","text":"nbstore.notebook<p> source module nbstore.notebook </p> <p>Utilities for working with Jupyter notebook content.</p> <p>This module provides functions for extracting and manipulating content from notebook cells, with a focus on cell identification by unique identifiers and data extraction from cell outputs.</p> <p> Functions </p> <ul> <li> <p>get_language \u2014 Get the programming language of a notebook.</p> </li> <li> <p>get_cell \u2014 Get a cell by its identifier.</p> </li> <li> <p>get_source \u2014 Get the source code of a cell by its identifier.</p> </li> <li> <p>get_outputs \u2014 Get the outputs of a cell by its identifier.</p> </li> <li> <p>get_stream \u2014 Get the stream output of a cell by its identifier.</p> </li> <li> <p>get_data \u2014 Get the data outputs of a cell by its identifier.</p> </li> <li> <p>get_mime_content \u2014 Get the MIME content of a cell by its identifier.</p> </li> <li> <p>add_data \u2014 Add data to a cell output by its identifier.</p> </li> <li> <p>new_code_cell \u2014 Create a new code cell with an identifier.</p> </li> <li> <p>execute \u2014 Execute a notebook.</p> </li> <li> <p>equals \u2014 Check if two notebooks have the same cells.</p> </li> </ul> <p> source get_language(nb: NotebookNode, default: str = 'python') \u2192 str </p> <p>Get the programming language of a notebook.</p> <p>Extracts the language from notebook metadata, either from the kernelspec or language_info sections.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to examine.</p> </li> <li> <p>default :  str \u2014 Default language to return if not found in metadata.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The programming language name.</p> </li> </ul> <p> source get_cell(nb: NotebookNode, identifier: str) \u2192 dict[str, Any] </p> <p>Get a cell by its identifier.</p> <p>Searches for a cell whose source code starts with a specific identifier pattern, supporting both \"# #\" and \"# %% #\" prefixes.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to search.</p> </li> <li> <p>identifier :  str \u2014 The identifier to look for.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>dict[str, Any] \u2014 The cell dictionary.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If no cell with the given identifier is found.</p> </li> </ul> <p> source get_source(nb: NotebookNode, identifier: str, *, include_identifier: bool = False) \u2192 str </p> <p>Get the source code of a cell by its identifier.</p> <p>Extracts the source code from a cell, optionally including the identifier line.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to search.</p> </li> <li> <p>identifier :  str \u2014 The identifier of the cell.</p> </li> <li> <p>include_identifier :  bool \u2014 Whether to include the identifier line.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The source code of the cell.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If no cell with the given identifier is found.</p> </li> <li> <p>NotImplementedError \u2014 If the cell has no source.</p> </li> </ul> <p> source get_outputs(nb: NotebookNode, identifier: str) \u2192 list[dict[str, Any]] </p> <p>Get the outputs of a cell by its identifier.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to search.</p> </li> <li> <p>identifier :  str \u2014 The identifier of the cell.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list \u2014 The outputs of the cell.</p> </li> </ul> <p> source get_stream(nb: NotebookNode, identifier: str) \u2192 str | None </p> <p>Get the stream output of a cell by its identifier.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to search.</p> </li> <li> <p>identifier :  str \u2014 The identifier of the cell.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | None \u2014 The stream output text, or None if not found.</p> </li> </ul> <p> source get_data(nb: NotebookNode, identifier: str) \u2192 dict[str, str] </p> <p>Get the data outputs of a cell by its identifier.</p> <p>Tries to find data in various output types, prioritizing display_data, execute_result, and stream in that order.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to search.</p> </li> <li> <p>identifier :  str \u2014 The identifier of the cell.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>dict[str, str] \u2014 The data dictionary, empty if no data is found.</p> </li> </ul> <p> source get_mime_content(nb: NotebookNode, identifier: str) \u2192 tuple[str, str | bytes] </p> <p>Get the MIME content of a cell by its identifier.</p> <p>Extracts the content of a cell output based on MIME type, prioritizing SVG, HTML, PDF, other images, and plain text in that order.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to search.</p> </li> <li> <p>identifier :  str \u2014 The identifier of the cell.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[str, str | bytes] \u2014 A tuple of (mime_type, content),     or (\"\", \"\") if no content is found.</p> </li> </ul> <p> source add_data(nb: NotebookNode, identifier: str, mime: str, data: str) \u2192 None </p> <p>Add data to a cell output by its identifier.</p> <p>Adds or updates data in a display_data output of a cell.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to modify.</p> </li> <li> <p>identifier :  str \u2014 The identifier of the cell.</p> </li> <li> <p>mime :  str \u2014 The MIME type of the data.</p> </li> <li> <p>data :  str \u2014 The data content.</p> </li> </ul> <p> source new_code_cell(identifier: str, source: str) \u2192 NotebookNode </p> <p>Create a new code cell with an identifier.</p> <p>If the source doesn't already have an identifier, one is added.</p> <p> Parameters </p> <ul> <li> <p>identifier :  str \u2014 The identifier for the cell.</p> </li> <li> <p>source :  str \u2014 The source code.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>NotebookNode \u2014 A new code cell.</p> </li> </ul> <p> source execute(nb: NotebookNode, timeout: int = 600) \u2192 tuple[NotebookNode, dict[str, Any]] </p> <p>Execute a notebook.</p> <p>Uses nbconvert's ExecutePreprocessor to run all cells in a notebook.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 The notebook to execute.</p> </li> <li> <p>timeout :  int \u2014 Maximum time in seconds to wait for each cell execution.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>tuple[NotebookNode, dict[str, Any]] \u2014 The executed notebook and execution info.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ModuleNotFoundError \u2014 If nbconvert is not installed.</p> </li> </ul> <p> source equals(nb: NotebookNode, other: NotebookNode) \u2192 bool </p> <p>Check if two notebooks have the same cells.</p> <p>Compares the number of cells and the source of each cell.</p> <p> Parameters </p> <ul> <li> <p>nb :  NotebookNode \u2014 First notebook.</p> </li> <li> <p>other :  NotebookNode \u2014 Second notebook.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the notebooks have the same cells, False otherwise.</p> </li> </ul>"},{"location":"api/nbstore/python/","title":"nbstore.python","text":"nbstore.python<p> source module nbstore.python </p> <p>Convert Python scripts to Jupyter notebooks.</p> <p>This module provides utilities for parsing Python scripts and converting them to notebook format, with support for cell markers and code block extraction.</p> <p> Functions </p> <ul> <li> <p>parse \u2014 Parse the text and yield sources.</p> </li> <li> <p>new_notebook \u2014 Create a new notebook from Python code.</p> </li> </ul> <p> source parse(text: str) \u2192 Iterator[str] </p> <p>Parse the text and yield sources.</p> <p>First splits the text at 'if name == \"main\":' lines, then splits each block at '# %%' cell markers.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The text to parse.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>str \u2014 The sources.</p> </li> </ul> <p> source new_notebook(text: str) \u2192 NotebookNode </p> <p>Create a new notebook from Python code.</p> <p>Parses the Python code, extracts cell sources, and creates a notebook with a code cell for each source.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The Python code to convert.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>NotebookNode \u2014 The created notebook.</p> </li> </ul>"},{"location":"api/nbstore/store/","title":"nbstore.store","text":"nbstore.store<p> source module nbstore.store </p> <p>Core functionality for reading and managing notebook files.</p> <p>This module provides the main interface for accessing notebook content from various file formats and managing notebook instances in memory.</p> <p> Classes </p> <ul> <li> <p>Store \u2014 Manage notebook files from one or more source directories.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>read \u2014 Read a notebook file and return its content.</p> </li> </ul> <p> source class Store(src_dirs: str | Path | Iterable[str | Path]) </p> <p>Manage notebook files from one or more source directories.</p> <p>Provides a centralized interface for reading notebook files and caching their content for efficient access. Automatically reloads files when they have been modified on disk.</p> <p>Initialize a new Store instance.</p> <p> Attributes </p> <ul> <li> <p>src_dirs :  list[Path] \u2014 List of source directories to search for notebook files.</p> </li> <li> <p>nodes :  dict[Path, NotebookNode] \u2014 Dictionary mapping file paths to their notebook nodes.</p> </li> <li> <p>st_mtime :  dict[Path, float] \u2014 Dictionary mapping file paths to their last modification times.</p> </li> <li> <p>url :  str \u2014 String representing the last accessed URL.</p> </li> </ul> <p> Parameters </p> <ul> <li> <p>src_dirs :  str | Path | Iterable[str | Path] \u2014 One or more directories to search for notebook files. Can be a single path or a collection of paths.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>find_path \u2014 Find the absolute path of a notebook file.</p> </li> <li> <p>read \u2014 Read a notebook file and return its content.</p> </li> <li> <p>write \u2014 Write a notebook node to a file.</p> </li> </ul> <p> source method Store.find_path(url: str) \u2192 Path </p> <p>Find the absolute path of a notebook file.</p> <p>Searches for the notebook file in the source directories. If the URL is an absolute path, it is returned directly.</p> <p> Parameters </p> <ul> <li> <p>url :  str \u2014 The URL or relative path of the notebook file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Path \u2014 The absolute path to the notebook file.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError \u2014 If the file cannot be found in any source directory.</p> </li> </ul> <p> source method Store.read(url: str) \u2192 NotebookNode </p> <p>Read a notebook file and return its content.</p> <p>If the file has been modified since it was last read, it is reloaded. If no URL is provided, the last URL is used.</p> <p> Parameters </p> <ul> <li> <p>url :  str \u2014 The URL or relative path of the notebook file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>NotebookNode \u2014 The notebook content.</p> </li> </ul> <p> source method Store.write(url: str, notebook_node: NotebookNode) \u2192 None </p> <p>Write a notebook node to a file.</p> <p>Currently only supports writing to .ipynb files.</p> <p> Parameters </p> <ul> <li> <p>url :  str \u2014 The URL or relative path of the notebook file.</p> </li> <li> <p>notebook_node :  NotebookNode \u2014 The notebook content to write.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>NotImplementedError \u2014 If the file format is not supported for writing.</p> </li> </ul> <p> source read(path: str | Path) \u2192 NotebookNode </p> <p>Read a notebook file and return its content.</p> <p>Supports .ipynb, .py, and .md file formats.</p> <p> Parameters </p> <ul> <li> <p>path :  str | Path \u2014 The path to the notebook file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>NotebookNode \u2014 The notebook content.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>NotImplementedError \u2014 If the file format is not supported.</p> </li> </ul>"}]}